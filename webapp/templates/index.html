<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>SOSParser</title>
    <link rel="icon" type="image/svg+xml" href="{{ url_for('report_images', filename='favicon.svg') }}">
    <link rel="stylesheet" href="{{ url_for('static', filename='main.css') }}">
  </head>
  <body>
    <div class="page-wrapper">
      <header class="header">
        <div class="container">
          <div class="header-content">
            <div class="title-section">
              <h1>SOSParser</h1>
              <p class="subtitle">Linux diagnostic file parser and analyzer</p>
              <p class="format-support">Supports SOSReport & Supportconfig formats</p>
            </div>
            <div class="header-actions">
              {% if not public_mode %}
              <button type="button" class="btn-secondary" id="browse-reports-btn">Saved Reports</button>
              {% endif %}
              <a class="icon-link" href="https://github.com/samatild/SOSParser" target="_blank" rel="noopener noreferrer" aria-label="GitHub">
                <svg viewBox="0 0 16 16" aria-hidden="true" focusable="false" class="icon-svg">
                  <path fill="currentColor" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.19 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
                </svg>
              </a>
            </div>
          </div>
        </div>
      </header>

      <main class="container">
        {% with messages = get_flashed_messages(with_categories=true) %}
          {% if messages %}
            <div class="flash-messages">
            {% for category, message in messages %}
              <div class="flash flash-{{ category }}">{{ message }}</div>
            {% endfor %}
            </div>
          {% endif %}
        {% endwith %}

        <div class="upload-card">
          <form id="analyze-form" method="post" action="{{ url_for('analyze') }}" enctype="multipart/form-data">
            <div class="form-group">
              <label for="sosreport_file">Diagnostic File</label>
              <div class="file-input-wrapper">
                <input 
                  id="sosreport_file" 
                  name="sosreport_file" 
                  type="file" 
                  accept=".tar.xz,.txz,.tar.gz,.tar.bz2,.tgz,.tar" 
                  required
                  class="file-input">
                <div class="file-input-display">
                  <span class="file-icon">ðŸ“¦</span>
                  <span class="file-text">Select file...</span>
                </div>
              </div>
              <div class="help-text">
                Formats: SOSReport (.tar.xz, .tar.gz, .tar.bz2, .tgz) | Supportconfig (.txz)
              </div>
            </div>

            <div class="form-actions">
              <button type="submit" class="btn-primary">Parse & Analyze</button>
            </div>
          </form>

          <div class="info-panel">
            <p>Automated analysis of sosreport (RHEL/CentOS/Ubuntu) and supportconfig (SUSE) files with comprehensive reporting. Format is auto-detected.</p>
          </div>
        </div>
      </main>

      <footer class="footer">
        <div class="container">
          <p>&copy; 2025 SOSParser v{{ version }} | Generated: {{ execution_timestamp }} UTC</p>
        </div>
      </footer>
    </div>

    <div id="upload-overlay" class="upload-overlay" style="display:none;">
      <div class="upload-content">
        <div class="upload-header">
          <span class="upload-icon">ðŸ“¤</span>
          <h2 id="upload-title">Uploading File</h2>
        </div>
        
        <div class="upload-progress-container">
          <div class="upload-progress-bar">
            <div class="upload-progress-fill" id="upload-progress-fill" style="width: 0%"></div>
          </div>
          <div class="upload-progress-text">
            <span id="upload-percentage">0%</span>
            <span id="upload-speed"></span>
          </div>
        </div>
        
        <div class="upload-stats">
          <div class="upload-stat">
            <span class="stat-label">Uploaded</span>
            <span class="stat-value" id="upload-bytes">0 B / 0 B</span>
          </div>
          <div class="upload-stat">
            <span class="stat-label">Time Remaining</span>
            <span class="stat-value" id="upload-eta">Calculating...</span>
          </div>
        </div>
        
        <p class="upload-status" id="upload-status">Preparing upload...</p>
        
        <!-- Collapsible Console -->
        <div class="console-container" id="console-container">
          <button type="button" class="console-toggle" id="console-toggle">
            <span class="console-toggle-icon">â–¶</span>
            <span class="console-toggle-text">Show Console Output</span>
          </button>
          <div class="console-panel" id="console-panel">
            <div class="console-header">
              <span class="console-title">Console Output</span>
              <button type="button" class="console-clear" id="console-clear" title="Clear">âŒ«</button>
            </div>
            <div class="console-output" id="console-output">
              <div class="console-line console-info">Waiting for analysis to start...</div>
            </div>
          </div>
        </div>
        
        <button type="button" class="btn-cancel" id="cancel-upload-btn">Cancel Upload</button>
      </div>
    </div>

    {% if not public_mode %}
    <div id="report-browser" class="report-browser">
      <div class="browser-header">
        <div>
          <h3>Saved Reports</h3>
          <p class="browser-subtitle">Open or delete generated reports</p>
        </div>
        <button class="icon-button" id="close-browser-btn" aria-label="Close">âœ•</button>
      </div>
      <div id="report-list" class="report-list">
        <p class="browser-empty">No reports found.</p>
      </div>
    </div>
    <div id="browser-backdrop" class="browser-backdrop" style="display:none;"></div>
    {% endif %}

    <script>
      // ========== Chunked Upload System ==========
      const CHUNK_SIZE = 5 * 1024 * 1024; // 5MB chunks
      let currentUpload = null;

      // Format bytes for display
      function formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const k = 1024;
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
      }

      // Format time remaining
      function formatETA(seconds) {
        if (!seconds || seconds === Infinity || seconds < 0) return 'Calculating...';
        if (seconds < 60) return `${Math.ceil(seconds)}s`;
        if (seconds < 3600) return `${Math.floor(seconds / 60)}m ${Math.ceil(seconds % 60)}s`;
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        return `${hours}h ${mins}m`;
      }

      // ========== Console Functions ==========
      let consoleExpanded = false;
      
      function toggleConsole(forceState) {
        const panel = document.getElementById('console-panel');
        const toggle = document.getElementById('console-toggle');
        const icon = toggle.querySelector('.console-toggle-icon');
        const text = toggle.querySelector('.console-toggle-text');
        
        consoleExpanded = forceState !== undefined ? forceState : !consoleExpanded;
        
        if (consoleExpanded) {
          panel.classList.add('expanded');
          icon.textContent = 'â–¼';
          text.textContent = 'Hide Console Output';
        } else {
          panel.classList.remove('expanded');
          icon.textContent = 'â–¶';
          text.textContent = 'Show Console Output';
        }
      }
      
      function clearConsole() {
        document.getElementById('console-output').innerHTML = '';
      }
      
      function addConsoleLine(message, type = 'default') {
        const output = document.getElementById('console-output');
        const line = document.createElement('div');
        line.className = `console-line console-${type}`;
        line.textContent = message;
        output.appendChild(line);
        // Auto-scroll to bottom
        output.scrollTop = output.scrollHeight;
      }
      
      // Console event handlers
      document.getElementById('console-toggle').addEventListener('click', () => toggleConsole());
      document.getElementById('console-clear').addEventListener('click', clearConsole);

      // Chunked uploader class
      class ChunkedUploader {
        constructor(file) {
          this.file = file;
          this.uploadId = null;
          this.totalChunks = 0;
          this.uploadedChunks = 0;
          this.uploadedBytes = 0;
          this.startTime = null;
          this.cancelled = false;
          this.speedSamples = [];
          this.lastSampleTime = 0;
          this.lastSampleBytes = 0;
        }

        updateProgress() {
          const percentage = Math.round((this.uploadedBytes / this.file.size) * 100);
          const now = Date.now();
          
          // Calculate speed (sample every 500ms)
          if (now - this.lastSampleTime >= 500) {
            const bytesDelta = this.uploadedBytes - this.lastSampleBytes;
            const timeDelta = (now - this.lastSampleTime) / 1000;
            const speed = bytesDelta / timeDelta;
            
            this.speedSamples.push(speed);
            if (this.speedSamples.length > 10) this.speedSamples.shift();
            
            this.lastSampleTime = now;
            this.lastSampleBytes = this.uploadedBytes;
          }
          
          // Average speed from samples
          const avgSpeed = this.speedSamples.length > 0 
            ? this.speedSamples.reduce((a, b) => a + b, 0) / this.speedSamples.length 
            : 0;
          
          // Calculate ETA
          const remainingBytes = this.file.size - this.uploadedBytes;
          const eta = avgSpeed > 0 ? remainingBytes / avgSpeed : Infinity;

          // Update UI
          document.getElementById('upload-progress-fill').style.width = `${percentage}%`;
          document.getElementById('upload-percentage').textContent = `${percentage}%`;
          document.getElementById('upload-speed').textContent = avgSpeed > 0 ? `${formatBytes(avgSpeed)}/s` : '';
          document.getElementById('upload-bytes').textContent = `${formatBytes(this.uploadedBytes)} / ${formatBytes(this.file.size)}`;
          document.getElementById('upload-eta').textContent = formatETA(eta);
          document.getElementById('upload-status').textContent = 'Uploading...';
        }

        async init() {
          const response = await fetch('/api/upload/init', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              filename: this.file.name,
              fileSize: this.file.size,
              chunkSize: CHUNK_SIZE,
            }),
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to initialize upload');
          }

          const data = await response.json();
          this.uploadId = data.uploadId;
          this.totalChunks = data.totalChunks;
          return data;
        }

        async uploadChunk(chunkIndex) {
          if (this.cancelled) throw new Error('Upload cancelled');

          const start = chunkIndex * CHUNK_SIZE;
          const end = Math.min(start + CHUNK_SIZE, this.file.size);
          const chunk = this.file.slice(start, end);

          const formData = new FormData();
          formData.append('uploadId', this.uploadId);
          formData.append('chunkIndex', chunkIndex);
          formData.append('chunk', chunk);

          const response = await fetch('/api/upload/chunk', {
            method: 'POST',
            body: formData,
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || `Failed to upload chunk ${chunkIndex}`);
          }

          this.uploadedChunks++;
          this.uploadedBytes = Math.min(end, this.file.size);
          this.updateProgress();

          return response.json();
        }

        async complete() {
          document.getElementById('upload-status').textContent = 'Starting analysis...';
          document.getElementById('upload-title').textContent = 'Analyzing Report';
          document.getElementById('upload-progress-fill').classList.add('analyzing');
          
          // Show and expand console for analysis phase
          document.getElementById('console-container').style.display = 'block';
          toggleConsole(true);
          clearConsole();
          addConsoleLine('Finalizing upload...', 'info');

          const response = await fetch('/api/upload/complete', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ uploadId: this.uploadId }),
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.error || 'Failed to complete upload');
          }

          const result = await response.json();
          
          if (result.status === 'processing' && result.token) {
            // Connect to SSE log stream
            addConsoleLine('Connecting to analysis stream...', 'info');
            return await this.streamLogs(result.token);
          }
          
          return result;
        }
        
        async streamLogs(token) {
          return new Promise((resolve, reject) => {
            const eventSource = new EventSource(`/api/analysis/${token}/logs`);
            
            eventSource.onmessage = (event) => {
              try {
                const data = JSON.parse(event.data);
                
                if (data.type === 'log') {
                  addConsoleLine(data.message);
                  document.getElementById('upload-status').textContent = 'Analyzing...';
                } else if (data.type === 'complete') {
                  eventSource.close();
                  addConsoleLine('Analysis complete! Redirecting...', 'success');
                  resolve({ redirectUrl: data.redirectUrl });
                } else if (data.type === 'error') {
                  eventSource.close();
                  addConsoleLine(`Error: ${data.error}`, 'error');
                  reject(new Error(data.error));
                }
                // Ignore heartbeat messages
              } catch (e) {
                console.warn('Failed to parse SSE message:', e);
              }
            };
            
            eventSource.onerror = (err) => {
              eventSource.close();
              addConsoleLine('Connection to analysis stream lost', 'error');
              // Try polling for status instead
              this.pollStatus(token).then(resolve).catch(reject);
            };
          });
        }
        
        async pollStatus(token) {
          addConsoleLine('Polling for analysis status...', 'info');
          while (true) {
            try {
              const response = await fetch(`/api/analysis/${token}/status`);
              const data = await response.json();
              
              if (data.status === 'complete') {
                addConsoleLine('Analysis complete!', 'success');
                return { redirectUrl: data.redirectUrl };
              } else if (data.status === 'error') {
                throw new Error(data.error || 'Analysis failed');
              }
            } catch (e) {
              if (e.message !== 'Analysis failed') {
                console.warn('Status poll error:', e);
              } else {
                throw e;
              }
            }
            await new Promise(r => setTimeout(r, 2000));
          }
        }

        async cancel() {
          this.cancelled = true;
          if (this.uploadId) {
            try {
              await fetch(`/api/upload/${this.uploadId}`, { method: 'DELETE' });
            } catch (e) {
              console.warn('Failed to cancel upload on server:', e);
            }
          }
        }

        async start() {
          this.startTime = Date.now();
          this.lastSampleTime = Date.now();
          this.lastSampleBytes = 0;

          // Initialize upload session
          await this.init();

          // Upload chunks sequentially (could be parallelized for better speed)
          for (let i = 0; i < this.totalChunks; i++) {
            if (this.cancelled) throw new Error('Upload cancelled');
            await this.uploadChunk(i);
          }

          // Complete and analyze
          return await this.complete();
        }
      }

      // Handle form submission
      document.getElementById('analyze-form').addEventListener('submit', async function(e) {
        e.preventDefault();
        
        const fileInput = document.getElementById('sosreport_file');
        const file = fileInput.files[0];
        
        if (!file) {
          alert('Please select a file first.');
          return;
        }

        // Show upload overlay
        const overlay = document.getElementById('upload-overlay');
        overlay.style.display = 'flex';
        
        // Reset UI state
        document.getElementById('upload-title').textContent = 'Uploading File';
        document.getElementById('upload-progress-fill').style.width = '0%';
        document.getElementById('upload-progress-fill').classList.remove('analyzing');
        document.getElementById('upload-percentage').textContent = '0%';
        document.getElementById('upload-speed').textContent = '';
        document.getElementById('upload-bytes').textContent = `0 B / ${formatBytes(file.size)}`;
        document.getElementById('upload-eta').textContent = 'Calculating...';
        document.getElementById('upload-status').textContent = 'Initializing upload...';
        document.getElementById('cancel-upload-btn').style.display = 'block';
        
        // Reset console (hidden during upload, shown during analysis)
        document.getElementById('console-container').style.display = 'none';
        clearConsole();
        toggleConsole(false);

        currentUpload = new ChunkedUploader(file);

        try {
          const result = await currentUpload.start();
          
          if (result.redirectUrl) {
            window.location.href = result.redirectUrl;
          }
        } catch (err) {
          overlay.style.display = 'none';
          if (err.message !== 'Upload cancelled') {
            alert('Upload failed: ' + err.message);
          }
        } finally {
          currentUpload = null;
        }
      });

      // Cancel upload button
      document.getElementById('cancel-upload-btn').addEventListener('click', async function() {
        if (currentUpload) {
          await currentUpload.cancel();
          document.getElementById('upload-overlay').style.display = 'none';
        }
      });

      // Update file input display
      document.getElementById('sosreport_file').addEventListener('change', function(e) {
        const display = document.querySelector('.file-text');
        if (e.target.files.length > 0) {
          const file = e.target.files[0];
          display.textContent = `${file.name} (${formatBytes(file.size)})`;
        } else {
          display.textContent = 'Select file...';
        }
      });

      // ========== Report Browser (only in non-public mode) ==========
      const browseBtn = document.getElementById('browse-reports-btn');
      if (browseBtn) {
        const browser = document.getElementById('report-browser');
        const backdrop = document.getElementById('browser-backdrop');
        const closeBtn = document.getElementById('close-browser-btn');
        const reportList = document.getElementById('report-list');

        function closeBrowser() {
          browser.classList.remove('active');
          backdrop.style.display = 'none';
        }

        function openBrowser() {
          browser.classList.add('active');
          backdrop.style.display = 'block';
          loadReports();
        }

        async function loadReports() {
          reportList.innerHTML = '<p class="browser-loading">Loading...</p>';
          try {
            const res = await fetch('/api/reports');
            if (!res.ok) throw new Error('Failed to load reports');
            const data = await res.json();
            renderReports(data.items || []);
          } catch (err) {
            reportList.innerHTML = '<p class="browser-error">Failed to load reports.</p>';
          }
        }

        function renderReports(items) {
          if (!items.length) {
            reportList.innerHTML = '<p class="browser-empty">No reports found.</p>';
            return;
          }
          const frag = document.createDocumentFragment();
          items.forEach((item) => {
            const name = (item.path || 'report.html').split('/')[0] || 'report';
            const row = document.createElement('div');
            row.className = 'report-row';

            const info = document.createElement('div');
            info.className = 'report-info';
            const title = document.createElement('div');
            title.className = 'report-token';
            title.textContent = name;
            const meta = document.createElement('div');
            meta.className = 'report-meta';
            const ts = item.modified ? new Date(item.modified).toLocaleString() : '';
            const size = item.size ? ` Â· ${Math.max(1, Math.round(item.size / 1024))} KB` : '';
            meta.textContent = `${item.path || 'report.html'}${ts ? ' Â· ' + ts : ''}${size}`;
            info.appendChild(title);
            info.appendChild(meta);

            const actions = document.createElement('div');
            actions.className = 'report-actions';

            const openBtn = document.createElement('a');
            openBtn.className = 'btn-link';
            openBtn.href = item.url || `/view/${encodeURIComponent(item.token)}?path=${encodeURIComponent(item.path || 'report.html')}`;
            openBtn.textContent = 'Open';
            actions.appendChild(openBtn);

            const delBtn = document.createElement('button');
            delBtn.className = 'btn-link danger';
            delBtn.textContent = 'Delete';
            delBtn.addEventListener('click', async () => {
              if (!confirm('Delete this report?')) return;
              try {
                const res = await fetch(`/api/reports/${encodeURIComponent(item.token)}`, { method: 'DELETE' });
                if (!res.ok) throw new Error();
                loadReports();
              } catch (err) {
                alert('Failed to delete report.');
              }
            });
            actions.appendChild(delBtn);

            row.appendChild(info);
            row.appendChild(actions);
            frag.appendChild(row);
          });
          reportList.innerHTML = '';
          reportList.appendChild(frag);
        }

        browseBtn.addEventListener('click', openBrowser);
        closeBtn.addEventListener('click', closeBrowser);
        backdrop.addEventListener('click', closeBrowser);
      }
    </script>
  </body>
</html>
